#include "raylib.h"
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <math.h> 

// Constants
#define SCREEN_WIDTH 1280
#define SCREEN_HEIGHT 720
#define CELL_SIZE 32
#define GRID_WIDTH (SCREEN_WIDTH / CELL_SIZE)   // 40 columns
#define GRID_HEIGHT (SCREEN_HEIGHT / CELL_SIZE) // 22 rows

// if you need help with winning the levels - 
// level 1 - go all the way to the left then up for the correct path 
// level 2 - go into the middle left collom for the first half then 4 to the left for the correct path 
// level 3 - the right path should show its self after 8 deaths if not then the wall on the right is fake and you need to go up it 

// Enums - to fill the maps/grids with 
typedef enum
{
    EMPTY,
    COLLISION,
    NPC,
    NPC2,
    NPC3,
    START,
    END,
    END2,
    END3,
    SCTEMPTY
} CellType;

// Global Variables
int diffculty = 0;                 // Game difficulty (0: Easy, 1: Medium, 2: Hard)
int playerdeaths = 0;              // Player death count
int grid[GRID_HEIGHT][GRID_WIDTH]; // Grid to store cell values
Vector2 playerPos = {20, 21};      // Player start position on the grids
int dx = 0, dy = 0;                // Movement directions 
Music backgroundMusic;             // Background music
RenderTexture2D pauseScreenTexture; // Texture to store the game screen for pause effect
bool pauseTextureReady = false;    // Flag to track if pause texture has been initialized
int totalDeaths = 0;              // Total deaths in the hole game

// Patterns for different maps for each level - E = ez, M = medium, H = hard
int pattern_E[GRID_HEIGHT][GRID_WIDTH] = {
    {COLLISION, COLLISION, COLLISION, COLLISION, COLLISION, COLLISION, COLLISION, COLLISION, COLLISION, COLLISION,
     COLLISION, COLLISION, COLLISION, COLLISION, COLLISION, COLLISION, COLLISION, COLLISION, COLLISION, COLLISION,
     END, COLLISION, COLLISION, COLLISION, COLLISION, COLLISION, COLLISION, COLLISION, COLLISION, COLLISION,
     COLLISION, COLLISION, COLLISION, COLLISION, COLLISION, COLLISION, COLLISION, COLLISION, COLLISION, COLLISION},

    {COLLISION, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY,
     EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY,
     EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, COLLISION, COLLISION},

    {COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, NPC, COLLISION, EMPTY, COLLISION, EMPTY,
     COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, NPC, COLLISION, EMPTY, COLLISION, EMPTY,
     COLLISION, EMPTY, COLLISION, NPC, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY,
     COLLISION, EMPTY, COLLISION, NPC, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, COLLISION},

    {COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY,
     COLLISION, NPC, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY,
     COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY,
     COLLISION, NPC, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, COLLISION},

    {COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, NPC,
     COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY,
     COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, NPC, COLLISION, EMPTY,
     COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, COLLISION},

    {COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY,
     COLLISION, EMPTY, COLLISION, NPC, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, NPC,
     COLLISION, NPC, COLLISION, NPC, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY,
     COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, NPC, COLLISION, COLLISION},

    {COLLISION, EMPTY, COLLISION, NPC, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY,
     COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY,
     COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, NPC,
     COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, NPC, COLLISION, EMPTY, COLLISION, COLLISION},

    {COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, NPC, COLLISION, EMPTY,
     COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY,
     COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, NPC, COLLISION, EMPTY, COLLISION, EMPTY,
     COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, COLLISION},

    {COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, NPC, COLLISION, EMPTY, COLLISION, EMPTY,
     COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, NPC, COLLISION, EMPTY,
     COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY,
     COLLISION, EMPTY, COLLISION, NPC, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, COLLISION},

    {COLLISION, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY,
     EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY,
     EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY,
     EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, COLLISION, COLLISION},

    {COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, NPC,
     COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY,
     COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, NPC,
     COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, COLLISION},

    {COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY,
     COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, NPC, COLLISION, EMPTY, COLLISION, EMPTY,
     COLLISION, NPC, COLLISION, EMPTY, COLLISION, NPC, COLLISION, EMPTY, COLLISION, EMPTY,
     COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, COLLISION},

    {COLLISION, EMPTY, COLLISION, NPC, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY,
     COLLISION, NPC, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY,
     COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY,
     COLLISION, NPC, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, COLLISION},

    {COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY,
     COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, NPC, COLLISION, EMPTY,
     COLLISION, EMPTY, COLLISION, NPC, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY,
     COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, NPC, COLLISION, EMPTY, COLLISION, COLLISION},

    {COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, NPC, COLLISION, EMPTY, COLLISION, NPC,
     COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY,
     COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, NPC, COLLISION, EMPTY,
     COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, COLLISION},

    {COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY,
     COLLISION, EMPTY, COLLISION, NPC, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY,
     COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY,
     COLLISION, EMPTY, COLLISION, NPC, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, COLLISION},

    {COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, NPC, COLLISION, EMPTY,
     COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, NPC,
     COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, NPC, COLLISION, EMPTY, COLLISION, EMPTY,
     COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, NPC, COLLISION, COLLISION},

    {COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY,
     COLLISION, NPC, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, NPC, COLLISION, EMPTY,
     COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, NPC,
     COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, COLLISION},

    {COLLISION, EMPTY, COLLISION, NPC, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY,
     COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, NPC, COLLISION, EMPTY, COLLISION, EMPTY,
     COLLISION, NPC, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY,
     COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, NPC, COLLISION, EMPTY, COLLISION, COLLISION},

    {COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY,
     COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY,
     COLLISION, EMPTY, COLLISION, NPC, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY,
     COLLISION, NPC, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, COLLISION},

    {COLLISION, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY,
     EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY,
     EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, COLLISION},

    {COLLISION, COLLISION, COLLISION, COLLISION, COLLISION, COLLISION, COLLISION, COLLISION, COLLISION, COLLISION,
     COLLISION, COLLISION, COLLISION, COLLISION, COLLISION, COLLISION, COLLISION, COLLISION, COLLISION, COLLISION,
     START, COLLISION, COLLISION, COLLISION, COLLISION, COLLISION, COLLISION, COLLISION, COLLISION, COLLISION,
     COLLISION, COLLISION, COLLISION, COLLISION, COLLISION, COLLISION, COLLISION, COLLISION, COLLISION, COLLISION},
};

int pattern_M[GRID_HEIGHT][GRID_WIDTH] = {
    {COLLISION, COLLISION, COLLISION, COLLISION, COLLISION, COLLISION, COLLISION, COLLISION, COLLISION, COLLISION,
     COLLISION, COLLISION, COLLISION, COLLISION, COLLISION, COLLISION, COLLISION, COLLISION, COLLISION, COLLISION,
     END2, COLLISION, COLLISION, COLLISION, COLLISION, COLLISION, COLLISION, COLLISION, COLLISION, COLLISION,
     COLLISION, COLLISION, COLLISION, COLLISION, COLLISION, COLLISION, COLLISION, COLLISION, COLLISION, COLLISION},

    {COLLISION, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY,
     EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY,
     EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, COLLISION, COLLISION},

    {COLLISION, NPC2, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY,
     COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, NPC2, COLLISION, EMPTY, COLLISION, EMPTY,
     COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, NPC2, COLLISION, EMPTY,
     COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, NPC2, COLLISION, COLLISION},

    {COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY,
     COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY,
     COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, NPC2, COLLISION, EMPTY, COLLISION, EMPTY,
     COLLISION, NPC2, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, COLLISION},

    {COLLISION, EMPTY, COLLISION, NPC2, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY,
     COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, NPC2, COLLISION, EMPTY,
     COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY,
     COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, COLLISION},

    {COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY,
     COLLISION, EMPTY, COLLISION, NPC2, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, NPC2,
     COLLISION, NPC2, COLLISION, NPC2, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY,
     COLLISION, EMPTY, COLLISION, NPC2, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, COLLISION},

    {COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, NPC2, COLLISION, EMPTY, COLLISION, EMPTY,
     COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY,
     COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, NPC2,
     COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, NPC2, COLLISION, EMPTY, COLLISION, COLLISION},

    {COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, NPC2,
     COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY,
     COLLISION, EMPTY, COLLISION, NPC2, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY,
     COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, COLLISION},

    {COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, NPC2, COLLISION, NPC2, COLLISION, EMPTY,
     COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY,
     COLLISION, NPC2, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY,
     COLLISION, NPC2, COLLISION, NPC2, COLLISION, NPC2, COLLISION, NPC2, COLLISION, COLLISION},

    {COLLISION, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY,
     EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY,
     EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY,
     EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, COLLISION, COLLISION},

    {COLLISION, NPC2, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY,
     COLLISION, NPC2, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY,
     COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY,
     COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, NPC2, COLLISION, COLLISION},

    {COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY,
     COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY,
     COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, NPC2, COLLISION, EMPTY, COLLISION, EMPTY,
     COLLISION, NPC2, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, COLLISION},

    {COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, NPC2, COLLISION, EMPTY, COLLISION, EMPTY,
     COLLISION, EMPTY, COLLISION, NPC2, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY,
     COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, NPC2,
     COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, COLLISION},

    {COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY,
     COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY,
     COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY,
     COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, COLLISION},

    {COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, NPC2,
     COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, NPC2, COLLISION, EMPTY,
     COLLISION, EMPTY, COLLISION, NPC2, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY,
     COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, COLLISION},

    {COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY,
     COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY,
     COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY,
     COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, COLLISION},

    {COLLISION, NPC2, COLLISION, NPC2, COLLISION, EMPTY, COLLISION, NPC2, COLLISION, EMPTY,
     COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY,
     COLLISION, NPC2, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY,
     COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, NPC2, COLLISION, EMPTY, COLLISION, COLLISION},

    {COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY,
     COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY,
     COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY,
     COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, COLLISION},

    {COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY,
     COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, NPC2, COLLISION, EMPTY, COLLISION, EMPTY,
     COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, NPC2,
     COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, COLLISION},

    {COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, NPC2, COLLISION, EMPTY,
     COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY,
     COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY,
     COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, COLLISION},

    {COLLISION, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY,
     EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY,
     EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, COLLISION},

    {COLLISION, COLLISION, COLLISION, COLLISION, COLLISION, COLLISION, COLLISION, COLLISION, COLLISION, COLLISION,
     COLLISION, COLLISION, COLLISION, COLLISION, COLLISION, COLLISION, COLLISION, COLLISION, COLLISION, COLLISION,
     START, COLLISION, COLLISION, COLLISION, COLLISION, COLLISION, COLLISION, COLLISION, COLLISION, COLLISION,
     COLLISION, COLLISION, COLLISION, COLLISION, COLLISION, COLLISION, COLLISION, COLLISION, COLLISION, COLLISION},
};

int pattern_H[GRID_HEIGHT][GRID_WIDTH] = {
    {COLLISION, COLLISION, COLLISION, COLLISION, COLLISION, COLLISION, COLLISION, COLLISION, COLLISION, COLLISION,
     COLLISION, COLLISION, COLLISION, COLLISION, COLLISION, COLLISION, COLLISION, COLLISION, COLLISION, COLLISION,
     END3, COLLISION, COLLISION, COLLISION, COLLISION, COLLISION, COLLISION, COLLISION, COLLISION, COLLISION,
     COLLISION, COLLISION, COLLISION, COLLISION, COLLISION, COLLISION, COLLISION, COLLISION, COLLISION, COLLISION},

    {COLLISION, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY,
     EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY,
     EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, SCTEMPTY, COLLISION},

    {COLLISION, NPC3, COLLISION, NPC3, COLLISION, NPC3, COLLISION, EMPTY, COLLISION, NPC3,
     COLLISION, NPC3, COLLISION, NPC3, COLLISION, NPC3, COLLISION, NPC3, COLLISION, NPC3,
     COLLISION, EMPTY, COLLISION, NPC3, COLLISION, NPC3, COLLISION, NPC3, COLLISION, NPC3,
     COLLISION, NPC3, COLLISION, NPC3, COLLISION, NPC3, COLLISION, EMPTY, SCTEMPTY, COLLISION},

    {COLLISION, NPC3, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY,
     COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY,
     COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, NPC3, COLLISION, EMPTY, COLLISION, EMPTY,
     COLLISION, NPC3, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, NPC3, SCTEMPTY, COLLISION},

    {COLLISION, NPC3, COLLISION, NPC3, COLLISION, EMPTY, COLLISION, NPC3, COLLISION, EMPTY,
     COLLISION, NPC3, COLLISION, NPC3, COLLISION, EMPTY, COLLISION, NPC3, COLLISION, EMPTY,
     COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY,
     COLLISION, NPC3, COLLISION, NPC3, COLLISION, NPC3, COLLISION, NPC3, SCTEMPTY, COLLISION},

    {COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY,
     COLLISION, EMPTY, COLLISION, NPC3, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, NPC3,
     COLLISION, NPC3, COLLISION, NPC3, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY,
     COLLISION, EMPTY, COLLISION, NPC3, COLLISION, EMPTY, COLLISION, NPC3, SCTEMPTY, COLLISION},

    {COLLISION, EMPTY, COLLISION, NPC3, COLLISION, NPC3, COLLISION, EMPTY, COLLISION, NPC3,
     COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY,
     COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, NPC3, COLLISION, NPC3,
     COLLISION, NPC3, COLLISION, EMPTY, COLLISION, NPC3, COLLISION, NPC3, SCTEMPTY, COLLISION},

    {COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, NPC3,
     COLLISION, NPC3, COLLISION, NPC3, COLLISION, NPC3, COLLISION, EMPTY, COLLISION, EMPTY,
     COLLISION, EMPTY, COLLISION, NPC3, COLLISION, NPC3, COLLISION, EMPTY, COLLISION, EMPTY,
     COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, NPC3, SCTEMPTY, COLLISION},

    {COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, NPC3, COLLISION, NPC3, COLLISION, EMPTY,
     COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY,
     COLLISION, NPC3, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY,
     COLLISION, NPC3, COLLISION, NPC3, COLLISION, NPC3, COLLISION, NPC3, SCTEMPTY, COLLISION},

    {COLLISION, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY,
     EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY,
     EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY,
     EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, SCTEMPTY, COLLISION},

    {COLLISION, NPC3, COLLISION, NPC3, COLLISION, NPC3, COLLISION, NPC3, COLLISION, NPC3,
     COLLISION, NPC3, COLLISION, EMPTY, COLLISION, NPC3, COLLISION, NPC3, COLLISION, NPC3,
     COLLISION, EMPTY, COLLISION, NPC3, COLLISION, NPC3, COLLISION, NPC3, COLLISION, NPC3,
     COLLISION, NPC3, COLLISION, NPC3, COLLISION, NPC3, COLLISION, NPC3, SCTEMPTY, COLLISION},

    {COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY,
     COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY,
     COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, NPC3, COLLISION, EMPTY, COLLISION, EMPTY,
     COLLISION, NPC3, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, SCTEMPTY, COLLISION},

    {COLLISION, NPC3, COLLISION, NPC3, COLLISION, NPC3, COLLISION, EMPTY, COLLISION, NPC3,
     COLLISION, NPC3, COLLISION, NPC3, COLLISION, NPC3, COLLISION, EMPTY, COLLISION, EMPTY,
     COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, NPC3,
     COLLISION, EMPTY, COLLISION, NPC3, COLLISION, NPC3, COLLISION, NPC3, SCTEMPTY, COLLISION},

    {COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY,
     COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY,
     COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, NPC3, COLLISION, EMPTY, COLLISION, EMPTY,
     COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, SCTEMPTY, COLLISION},

    {COLLISION, EMPTY, COLLISION, NPC3, COLLISION, NPC3, COLLISION, NPC3, COLLISION, NPC3,
     COLLISION, NPC3, COLLISION, NPC3, COLLISION, NPC3, COLLISION, NPC3, COLLISION, EMPTY,
     COLLISION, NPC3, COLLISION, NPC3, COLLISION, EMPTY, COLLISION, NPC3, COLLISION, NPC3,
     COLLISION, NPC3, COLLISION, NPC3, COLLISION, NPC3, COLLISION, EMPTY, SCTEMPTY, COLLISION},

    {COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY,
     COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY,
     COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY,
     COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, SCTEMPTY, COLLISION},

    {COLLISION, NPC3, COLLISION, NPC3, COLLISION, EMPTY, COLLISION, NPC3, COLLISION, NPC3,
     COLLISION, NPC3, COLLISION, NPC3, COLLISION, NPC3, COLLISION, NPC3, COLLISION, NPC3,
     COLLISION, NPC3, COLLISION, EMPTY, COLLISION, NPC3, COLLISION, NPC3, COLLISION, NPC3,
     COLLISION, NPC3, COLLISION, NPC3, COLLISION, NPC3, COLLISION, NPC3, SCTEMPTY, COLLISION},

    {COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY,
     COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY,
     COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY,
     COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, SCTEMPTY, COLLISION},

    {COLLISION, EMPTY, COLLISION, NPC3, COLLISION, NPC3, COLLISION, NPC3, COLLISION, NPC3,
     COLLISION, NPC3, COLLISION, NPC3, COLLISION, NPC3, COLLISION, NPC3, COLLISION, NPC3,
     COLLISION, EMPTY, COLLISION, NPC3, COLLISION, NPC3, COLLISION, NPC3, COLLISION, NPC3,
     COLLISION, NPC3, COLLISION, NPC3, COLLISION, NPC3, COLLISION, NPC3, SCTEMPTY, COLLISION},

    {COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, NPC3, COLLISION, EMPTY, COLLISION, EMPTY,
     COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY,
     COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY,
     COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, COLLISION, EMPTY, SCTEMPTY, COLLISION},

    {COLLISION, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY,
     EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY,
     EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, SCTEMPTY, COLLISION},

    {COLLISION, COLLISION, COLLISION, COLLISION, COLLISION, COLLISION, COLLISION, COLLISION, COLLISION, COLLISION,
     COLLISION, COLLISION, COLLISION, COLLISION, COLLISION, COLLISION, COLLISION, COLLISION, COLLISION, COLLISION,
     START, COLLISION, COLLISION, COLLISION, COLLISION, COLLISION, COLLISION, COLLISION, COLLISION, COLLISION,
     COLLISION, COLLISION, COLLISION, COLLISION, COLLISION, COLLISION, COLLISION, COLLISION, COLLISION, COLLISION},
};

// Game State Flags set as booleans
bool isPaused = false;
bool isGameOver = false;
bool isnpc = false;
bool isStart = true;
bool isnpc2 = false;
bool isnpc3 = false;
bool isWin = false;
bool win_e = false;
bool win_m = false;
bool win_h = false;
bool secret = false;

// Function Prototypes - declare the functions 
void InitPatternGrid(int pattern[GRID_HEIGHT][GRID_WIDTH]);
void DrawStartScreen();
void DrawWinScreen();
void UpdatePlayer();
void GameGrid(void);
void DrawPlayer();
void DrawGameOverScreen();
void DrawPausedScreen(); 

// function initializes the global grid variable
void InitPatternGrid(int pattern[GRID_HEIGHT][GRID_WIDTH])
{
    for (int y = 0; y < GRID_HEIGHT; y++)
    {
        for (int x = 0; x < GRID_WIDTH; x++)
        {
            grid[y][x] = pattern[y][x];
        }
    }
}

void DrawStartScreen()
{
    // Create a gradient background for the lobby screen
    for (int y = 0; y < SCREEN_HEIGHT; y++) 
    {
        float factor = (float)y / SCREEN_HEIGHT; 
        Color topColor = (Color){25, 25, 112, 255}; // Midnight Blue
        Color bottomColor = (Color){0, 0, 0, 255};  // Black

        Color gradientColor = {
            (unsigned char)((1 - factor) * topColor.r + factor * bottomColor.r), 
            (unsigned char)((1 - factor) * topColor.g + factor * bottomColor.g),
            (unsigned char)((1 - factor) * topColor.b + factor * bottomColor.b),
            255};

        DrawLine(0, y, SCREEN_WIDTH, y, gradientColor);
    }

    // Draw decorative border for the lobby screen
    DrawRectangleLinesEx((Rectangle){20, 20, SCREEN_WIDTH - 40, SCREEN_HEIGHT - 40}, 4, RAYWHITE);
    DrawRectangleLinesEx((Rectangle){30, 30, SCREEN_WIDTH - 60, SCREEN_HEIGHT - 60}, 2, SKYBLUE);

    // Draw title with shadow effect for the lobby screen
    Color titleColor = RAYWHITE;
    const char *title = "THE EVIL MAZE";
    int fontSize = 60;
    int titleWidth = MeasureText(title, fontSize);

    // Shadow
    DrawText(title, SCREEN_WIDTH / 2 - titleWidth / 2 + 4, 80 + 4, fontSize, BLACK);
    // Main text
    DrawText(title, SCREEN_WIDTH / 2 - titleWidth / 2, 80, fontSize, titleColor);

    // Draw subtitle
    DrawText("Select The Difficulty", SCREEN_WIDTH / 2 - MeasureText("Select The Difficulty", 40) / 2, SCREEN_HEIGHT / 2 - 100, 40, GOLD);

    // Create a semi-transparent panel for difficulty options
    DrawRectangle(SCREEN_WIDTH / 2 - 200, SCREEN_HEIGHT / 2 - 50, 400, 250, (Color){0, 0, 0, 150});
    DrawRectangleLinesEx((Rectangle){SCREEN_WIDTH / 2 - 200, SCREEN_HEIGHT / 2 - 50, 400, 250}, 2, SKYBLUE);

    // Drawing the difficulty mode or compleated options with some nice styling
    if (!win_e)
    {
        DrawText("1: Easy", SCREEN_WIDTH / 2 - MeasureText("1: Easy", 30) / 2, SCREEN_HEIGHT / 2 - 20, 30, GREEN);
    }
    else
    {
        DrawText("1:(Completed)", SCREEN_WIDTH / 2 - MeasureText("1:(Completed)", 30) / 2, SCREEN_HEIGHT / 2 - 20, 30, GRAY);
    }

    if (!win_m)
    {
        DrawText("2: Medium", SCREEN_WIDTH / 2 - MeasureText("2: Medium", 30) / 2, SCREEN_HEIGHT / 2 + 20, 30, YELLOW);
    }
    else
    {
        DrawText("2:(Completed)", SCREEN_WIDTH / 2 - MeasureText("2:(Completed)", 30) / 2, SCREEN_HEIGHT / 2 + 20, 30, GRAY);
    }

    if (!win_h)
    {
        DrawText("3: Hard", SCREEN_WIDTH / 2 - MeasureText("3: Hard", 30) / 2, SCREEN_HEIGHT / 2 + 60, 30, RED);
    }
    else
    {
        DrawText("3:(Completed)", SCREEN_WIDTH / 2 - MeasureText("3:(Completed)", 30) / 2, SCREEN_HEIGHT / 2 + 60, 30, GRAY);
    }

    // Bottom instruction with pulsating effect
    float time = GetTime();
    float alpha = (sinf(time * 3) + 1) * 0.5f * 255; // Pulsating alpha between 0 and 255
    Color instructionColor = (Color){255, 255, 255, (unsigned char)alpha};

    if (win_e && win_m && win_h) // checks if all levels have been beat
    {
        // Show total death count with pulsating effect
        char totalDeathsText[50];
        sprintf(totalDeathsText, "Total Deaths: %d", totalDeaths);
        DrawText(totalDeathsText, SCREEN_WIDTH / 2 - MeasureText(totalDeathsText, 30) / 2, SCREEN_HEIGHT / 2 + 130, 30, instructionColor);
    }
    else
    {
        DrawText("Complete all levels to unlock secrets!", SCREEN_WIDTH / 2 - MeasureText("Complete all levels to unlock secrets!", 24) / 2, SCREEN_HEIGHT / 2 + 130, 24, instructionColor);
    }

    // Create a semi-transparent control panel higher up on the screen (moved up by 40 pixels)
    DrawRectangle(0, SCREEN_HEIGHT - 130, SCREEN_WIDTH, 90, (Color){0, 0, 30, 180});
    DrawLine(0, SCREEN_HEIGHT - 130, SCREEN_WIDTH, SCREEN_HEIGHT - 130, SKYBLUE);

    // Draw game controls instructions with visuals
    DrawText("Controls:", 30, SCREEN_HEIGHT - 115, 20, SKYBLUE);
    
    // Movement controls
    DrawText("Movement:", 30, SCREEN_HEIGHT - 85, 18, WHITE);
    
    // WASD keys
    DrawRectangle(150, SCREEN_HEIGHT - 105, 35, 35, DARKGRAY);
    DrawRectangleLines(150, SCREEN_HEIGHT - 105, 35, 35, WHITE);
    DrawText("W", 160, SCREEN_HEIGHT - 100, 20, WHITE);
    
    DrawRectangle(150, SCREEN_HEIGHT - 65, 35, 35, DARKGRAY);
    DrawRectangleLines(150, SCREEN_HEIGHT - 65, 35, 35, WHITE);
    DrawText("S", 160, SCREEN_HEIGHT - 60, 20, WHITE);
    
    DrawRectangle(110, SCREEN_HEIGHT - 65, 35, 35, DARKGRAY);
    DrawRectangleLines(110, SCREEN_HEIGHT - 65, 35, 35, WHITE);
    DrawText("A", 120, SCREEN_HEIGHT - 60, 20, WHITE);
    
    DrawRectangle(190, SCREEN_HEIGHT - 65, 35, 35, DARKGRAY);
    DrawRectangleLines(190, SCREEN_HEIGHT - 65, 35, 35, WHITE);
    DrawText("D", 200, SCREEN_HEIGHT - 60, 20, WHITE);
    
    // Arrow keys - increase spacing between "or" and arrow keys (from 280 to 310)
    DrawText("or", 250, SCREEN_HEIGHT - 80, 18, LIGHTGRAY);
    
    // Fix arrow key symbols by using text instead of Unicode characters
    DrawRectangle(350, SCREEN_HEIGHT - 105, 35, 35, DARKGRAY);
    DrawRectangleLines(350, SCREEN_HEIGHT - 105, 35, 35, WHITE);
    DrawText("UP", 357, SCREEN_HEIGHT - 100, 16, WHITE);
    
    DrawRectangle(350, SCREEN_HEIGHT - 65, 35, 35, DARKGRAY);
    DrawRectangleLines(350, SCREEN_HEIGHT - 65, 35, 35, WHITE);
    DrawText("DN", 357, SCREEN_HEIGHT - 60, 16, WHITE);
    
    DrawRectangle(310, SCREEN_HEIGHT - 65, 35, 35, DARKGRAY);
    DrawRectangleLines(310, SCREEN_HEIGHT - 65, 35, 35, WHITE);
    DrawText("LT", 317, SCREEN_HEIGHT - 60, 16, WHITE);
    
    DrawRectangle(390, SCREEN_HEIGHT - 65, 35, 35, DARKGRAY);
    DrawRectangleLines(390, SCREEN_HEIGHT - 65, 35, 35, WHITE);
    DrawText("RT", 397, SCREEN_HEIGHT - 60, 16, WHITE);
    
    // Other controls - adjust position to accommodate the wider spacing
    DrawText("Other:", 470, SCREEN_HEIGHT - 115, 18, WHITE);
    
    // Pause key
    DrawRectangle(470, SCREEN_HEIGHT - 85, 35, 35, DARKGRAY);
    DrawRectangleLines(470, SCREEN_HEIGHT - 85, 35, 35, WHITE);
    DrawText("P", 480, SCREEN_HEIGHT - 80, 20, WHITE);
    DrawText("- Pause", 515, SCREEN_HEIGHT - 80, 18, LIGHTGRAY);
    
    // Restart key
    DrawRectangle(590, SCREEN_HEIGHT - 85, 35, 35, DARKGRAY);
    DrawRectangleLines(590, SCREEN_HEIGHT - 85, 35, 35, WHITE);
    DrawText("T", 600, SCREEN_HEIGHT - 80, 20, WHITE);
    DrawText("- Restart", 635, SCREEN_HEIGHT - 80, 18, LIGHTGRAY);
    
    // Home key
    DrawRectangle(730, SCREEN_HEIGHT - 85, 35, 35, DARKGRAY);
    DrawRectangleLines(730, SCREEN_HEIGHT - 85, 35, 35, WHITE);
    DrawText("O", 740, SCREEN_HEIGHT - 80, 20, WHITE);
    DrawText("- Return to home screan", 775, SCREEN_HEIGHT - 80, 18, LIGHTGRAY);
}

void DrawWinScreen()
{
    // Create a gradient background for the win screen
    for (int y = 0; y < SCREEN_HEIGHT; y++)
    {
        float factor = (float)y / SCREEN_HEIGHT;
        Color topColor = (Color){50, 100, 180, 255}; // Blue top
        Color bottomColor = (Color){20, 30, 70, 255};  // Darker blue bottom

        Color gradientColor = {
            (unsigned char)((1 - factor) * topColor.r + factor * bottomColor.r),
            (unsigned char)((1 - factor) * topColor.g + factor * bottomColor.g),
            (unsigned char)((1 - factor) * topColor.b + factor * bottomColor.b),
            255};

        DrawLine(0, y, SCREEN_WIDTH, y, gradientColor);
    }
    
    // Draw decorative border
    DrawRectangleLinesEx((Rectangle){20, 20, SCREEN_WIDTH - 40, SCREEN_HEIGHT - 40}, 4, GOLD);
    DrawRectangleLinesEx((Rectangle){30, 30, SCREEN_WIDTH - 60, SCREEN_HEIGHT - 60}, 2, ORANGE);
    
    const char *winMessage;

    if (diffculty == 1)
    {
        winMessage = "Nice you beat Easy!";
    }
    else if (diffculty == 2)
    {
        winMessage = "Impressive! You won on Medium!";
    }
    else if (diffculty == 3)
    {
        winMessage = "Amazing! You conquered Hard mode!";
    }
    else
    {
        winMessage = "Good you win";
    }

    // Shadow effect for win message
    DrawText(winMessage, SCREEN_WIDTH / 2 - MeasureText(winMessage, 40) / 2 + 3, SCREEN_HEIGHT / 2 - 60 + 3, 40, BLACK);
    DrawText(winMessage, SCREEN_WIDTH / 2 - MeasureText(winMessage, 40) / 2, SCREEN_HEIGHT / 2 - 60, 40, WHITE);
    
    // Create a visually distinct button to return to lobby
    Rectangle btnBounds = {SCREEN_WIDTH / 2 - 150, SCREEN_HEIGHT / 2 + 50, 300, 60};
    Color btnColor = DARKBLUE;
    Color btnBorderColor = BLUE;
    
    // Button hover effect
    if (CheckCollisionPointRec(GetMousePosition(), btnBounds)) {
        btnColor = BLUE;
        btnBorderColor = SKYBLUE;
        
        // Click handling
        if (IsMouseButtonPressed(MOUSE_LEFT_BUTTON)) {
            diffculty = 0;
            playerdeaths = 0;
            isStart = true;
            isnpc = false;
            isWin = false;
            isGameOver = false;
            playerPos.x = 20;
            playerPos.y = 21;
        }
    }
    
    // Draw button
    DrawRectangleRec(btnBounds, btnColor);
    DrawRectangleLinesEx(btnBounds, 3, btnBorderColor);
    DrawText("Return to Lobby", btnBounds.x + (btnBounds.width / 2) - MeasureText("Return to Lobby", 25) / 2, 
             btnBounds.y + (btnBounds.height / 2) - 12, 25, WHITE);
    
    // draw the returen to lobby button in message
    DrawText("Or press O to return", SCREEN_WIDTH / 2 - MeasureText("Or press O to return", 20) / 2, SCREEN_HEIGHT - 50, 20, LIGHTGRAY);

    if (IsKeyPressed(KEY_O))
    {
        diffculty = 0;
        playerdeaths = 0;
        isStart = true;
        isnpc = false;
        isWin = false;
        isGameOver = false;
        playerPos.x = 20;
        playerPos.y = 21;
    }
}

void UpdatePlayer()
{
    // Check for O key press to return to lobby from anywhere
    if (IsKeyPressed(KEY_O))
    {
        diffculty = 0;
        playerdeaths = 0;
        isStart = true;
        isnpc = false;
        isnpc2 = false;
        isnpc3 = false;
        isWin = false;
        isGameOver = false;
        isPaused = false;
        playerPos.x = 20;
        playerPos.y = 21;
        return;
    }

    if (IsKeyPressed(KEY_P))
    {
        isPaused = !isPaused;
    }

    // this dosen't allow movement during pause or when displaying death message
    if (isPaused || isGameOver || isnpc || isnpc2 || isnpc3)
    {
        // Only handle the respawn key press when in death state
        if ((isnpc || isnpc2 || isnpc3) && IsKeyPressed(KEY_T))
        {
            playerPos.x = 20;
            playerPos.y = 21;
            isnpc = false;
            isnpc2 = false;
            isnpc3 = false;
        }
        return;
    }

    if (diffculty == 0)
    {
        // ...existing difficulty selection code...
        if (IsKeyPressed(KEY_ONE) && !win_e)
        {
            diffculty = 1;
            isStart = false;
            InitPatternGrid(pattern_E);
        }
        else if (IsKeyPressed(KEY_TWO))
        {
            diffculty = 2;
            isStart = false;
            InitPatternGrid(pattern_M);
        }
        else if (IsKeyPressed(KEY_THREE))
        {
            diffculty = 3;
            isStart = false;
            InitPatternGrid(pattern_H);
        }
        return;
    }

    // Handle movement
    if (IsKeyPressed(KEY_W) && playerPos.y > 0 && grid[(int)playerPos.y - 1][(int)playerPos.x] != COLLISION)
        playerPos.y--;
    if (IsKeyPressed(KEY_S) && playerPos.y < GRID_HEIGHT - 1 && grid[(int)playerPos.y + 1][(int)playerPos.x] != COLLISION)
        playerPos.y++;
    if (IsKeyPressed(KEY_A) && playerPos.x > 0 && grid[(int)playerPos.y][(int)playerPos.x - 1] != COLLISION)
        playerPos.x--;
    if (IsKeyPressed(KEY_D) && playerPos.x < GRID_WIDTH - 1 && grid[(int)playerPos.y][(int)playerPos.x + 1] != COLLISION)
        playerPos.x++;

    if (IsKeyDown(KEY_UP) && playerPos.y > 0 && grid[(int)playerPos.y - 1][(int)playerPos.x] != COLLISION)
        playerPos.y--;
    if (IsKeyDown(KEY_DOWN) && playerPos.y < GRID_HEIGHT - 1 && grid[(int)playerPos.y + 1][(int)playerPos.x] != COLLISION)
        playerPos.y++;
    if (IsKeyDown(KEY_LEFT) && playerPos.x > 0 && grid[(int)playerPos.y][(int)playerPos.x - 1] != COLLISION)
        playerPos.x--;
    if (IsKeyDown(KEY_RIGHT) && playerPos.x < GRID_WIDTH - 1 && grid[(int)playerPos.y][(int)playerPos.x + 1] != COLLISION)
        playerPos.x++;

    // Check for different end conditions
    if (grid[(int)playerPos.y][(int)playerPos.x] == END)
    {
        isWin = true;
        isGameOver = true;
        if (diffculty == 1)
            win_e = true;
        return;
    }
    else if (grid[(int)playerPos.y][(int)playerPos.x] == END2)
    {
        isWin = true;
        isGameOver = true;
        if (diffculty == 2)
            win_m = true;
        return;
    }
    else if (grid[(int)playerPos.y][(int)playerPos.x] == END3)
    {
        isWin = true;
        isGameOver = true;
        if (diffculty == 3)
            win_h = true;
        return;
    }

    // Check for start position
    if (grid[(int)playerPos.y][(int)playerPos.x] == START)
    {
        isStart = true;
        isnpc = false;
        isnpc2 = false;
        isnpc3 = false;
    }
    else if (grid[(int)playerPos.y][(int)playerPos.x] == EMPTY)
    {
        isStart = false;
    }

    // Check for NPC3 collision
    if (grid[(int)playerPos.y][(int)playerPos.x] == NPC3)
    {
        isnpc3 = true;
        playerdeaths++;
        totalDeaths ++;
        return;
    }

    // Check for NPC2 collision
    if (grid[(int)playerPos.y][(int)playerPos.x] == NPC2)
    {
        isnpc2 = true;
        playerdeaths++;
        totalDeaths ++;
        return;
    }

    // Check for NPC collision
    if (grid[(int)playerPos.y][(int)playerPos.x] == NPC)
    {
        isnpc = true;
        playerdeaths++;
        totalDeaths ++;
        return;
    }

    // Manual respawn to start with F key (emergency key if player is stuck)
    if (IsKeyPressed(KEY_F))
    {
        playerPos.x = 20;
        playerPos.y = 21;
    }

    // Reset game state but keep at current position
    if (IsKeyPressed(KEY_T) && !isnpc && !isnpc2)
    {
        isGameOver = false;
        isWin = false;
    }
}

void GameGrid(void)
{
    // Draw a subtle background gradient based on difficulty
    Color gradientTop, gradientBottom;
    switch (diffculty)
    {
    case 1:                                      
        gradientTop = (Color){15, 45, 120, 255}; // Easy
        gradientBottom = (Color){0, 0, 40, 255};// Brighter blue
        break;
    case 2:                                      
        gradientTop = (Color){120, 15, 45, 255}; // Medium
        gradientBottom = (Color){40, 0, 0, 255};// Brighter red
        break;
    case 3:                                      
        gradientTop = (Color){45, 120, 15, 255}; // Hard
        gradientBottom = (Color){0, 40, 0, 255};// Brighter green
        break;
    default:
        gradientTop = (Color){30, 30, 90, 255}; // Brighter default
        gradientBottom = (Color){0, 0, 30, 255};
    }

    for (int y = 0; y < SCREEN_HEIGHT; y++)
    {
        float factor = (float)y / SCREEN_HEIGHT;
        Color gradientColor = {
            (unsigned char)((1 - factor) * gradientTop.r + factor * gradientBottom.r),
            (unsigned char)((1 - factor) * gradientTop.g + factor * gradientBottom.g),
            (unsigned char)((1 - factor) * gradientTop.b + factor * gradientBottom.b),
            255};
        DrawLine(0, y, SCREEN_WIDTH, y, gradientColor);
    }

    // Draw grid cells with visuals
    float time = GetTime();
    for (int y = 0; y < GRID_HEIGHT; y++)
    {
        for (int x = 0; x < GRID_WIDTH; x++)
        {
            Color cellColor = BLACK;
            Color borderColor = DARKGRAY;
            bool drawPattern = false;
            bool drawGlow = false;
            float pulseAmount = 0;
            float intensity = 0;

            switch (grid[y][x])
            {
            case COLLISION:
                // Create different wall color based on difficulty
                if (diffculty == 1)
                {
                    cellColor = (Color){40, 80, 160, 255}; // Brighter deep blue for easy
                    borderColor = (Color){60, 140, 200, 255};
                    drawPattern = true;
                }
                else if (diffculty == 2)
                {
                    cellColor = (Color){160, 40, 40, 255}; // Brighter deep red for medium
                    borderColor = (Color){200, 60, 60, 255};
                    drawPattern = true;
                }
                else if (diffculty == 3)
                {
                    cellColor = (Color){40, 120, 40, 255}; // Brighter deep green for hard
                    borderColor = (Color){60, 180, 60, 255};
                    drawPattern = true;
                }
                break;

            case END:
            case END2:
            case END3:
                pulseAmount = sinf(time * 2) * 0.3f + 0.7f;
                drawGlow = true;

                // checks the end blocks on the grid then i chenges the color of them for the difficulty
                if (grid[y][x] == END) 
                {
                    cellColor = (Color){(unsigned char)(255 * pulseAmount),
                                        (unsigned char)(220 * pulseAmount),
                                        0, 255}; // Brighter golden yellow
                }
                else if (grid[y][x] == END2)
                {
                    cellColor = (Color){(unsigned char)(255 * pulseAmount),
                                        (unsigned char)(160 * pulseAmount),
                                        0, 255}; // Brighter orange
                }
                else
                {
                    cellColor = (Color){(unsigned char)(220 * pulseAmount),
                                        (unsigned char)(40 * pulseAmount),
                                        (unsigned char)(220 * pulseAmount), 255}; // Brighter purple
                }
                borderColor = WHITE;
                break;

            case NPC:
            case NPC2:
            case NPC3:
                // Make NPCs look like the empty blocks
                intensity = (sinf(x * 0.2f + y * 0.2f + time * 0.5f) + 1) * 0.5f * 0.15f;
                cellColor = (Color){
                    (unsigned char)(10 * intensity),
                    (unsigned char)(10 * intensity),
                    (unsigned char)(20 * intensity),
                    255};
                borderColor = (Color){20, 20, 30, 50};
                break;

            // makes the start block have better visuals
            case START:
                pulseAmount = sinf(time * 2) * 0.3f + 0.7f;
                cellColor = (Color){0, (unsigned char)(230 * pulseAmount), 0, 255}; // Brighter green
                borderColor = (Color){120, 255, 120, 255};
                drawGlow = true;
                break;

            case SCTEMPTY:
                // lets the person playing know the secret path if they did not find it after 7 deaths then shows them the path
                // Check if we're on hard difficulty and have 7+ deaths
                if (diffculty == 3 && playerdeaths >= 7) {
                    // Make SCTEMPTY cells stand out as a clear path
                    pulseAmount = sinf(time * 3) * 0.3f + 0.7f;
                    cellColor = (Color){
                        (unsigned char)(255 * pulseAmount),  // Bright gold/yellow path
                        (unsigned char)(215 * pulseAmount),
                        (unsigned char)(0 * pulseAmount),
                        255};
                    borderColor = WHITE;
                    drawGlow = true;
                    
                    // Add text hint on the first SCTEMPTY cell (row 2, column 38)
                    if (y == 2 && x == 38) {
                        DrawText("S", x * CELL_SIZE + CELL_SIZE/3, y * CELL_SIZE + CELL_SIZE/4, CELL_SIZE/2, BLACK);
                    }
                    // Add text hint on the last SCTEMPTY cell (row 21, column 38)
                    else if (y == 21 && x == 38) {
                        DrawText("E", x * CELL_SIZE + CELL_SIZE/3, y * CELL_SIZE + CELL_SIZE/4, CELL_SIZE/2, BLACK);
                    }
                } else {
                    // Make SCTEMPTY look like collision cells in hard mode (unchanged appearance)
                    cellColor = (Color){40, 120, 40, 255}; // Same as collision in hard mode
                    borderColor = (Color){60, 180, 60, 255};
                    drawPattern = true;
                }
                break;

            case EMPTY:
                // Create subtle patterns for the empty blocks
                intensity = (sinf(x * 0.2f + y * 0.2f + time * 0.5f) + 1) * 0.5f * 0.15f;
                cellColor = (Color){
                    (unsigned char)(15 * intensity),
                    (unsigned char)(15 * intensity),
                    (unsigned char)(30 * intensity),
                    255};
                borderColor = (Color){30, 30, 45, 50};
                break;
            }

            // Draw the base cell
            DrawRectangle(x * CELL_SIZE, y * CELL_SIZE, CELL_SIZE, CELL_SIZE, cellColor);

            // Add patterns or textures to walls and other elements
            if (drawPattern)
            {
                for (int i = 0; i < CELL_SIZE; i += 4)
                {
                    // Different pattern styles based on cell type
                    if (grid[y][x] == COLLISION || (grid[y][x] == SCTEMPTY && !(diffculty == 3 && playerdeaths >= 7)))
                    {
                        DrawLine(x * CELL_SIZE + i, y * CELL_SIZE,
                                 x * CELL_SIZE, y * CELL_SIZE + i,
                                 ColorAlpha(borderColor, 0.3f));
                    }
                }
            }

            // Add glow effect to special cells effects 
            if (drawGlow)
            {
                for (int i = 1; i <= 3; i++)
                {
                    DrawRectangleLinesEx(
                        (Rectangle){
                            x * CELL_SIZE - i,
                            y * CELL_SIZE - i,
                            CELL_SIZE + i * 2,
                            CELL_SIZE + i * 2},
                        1,
                        ColorAlpha(borderColor, 0.2f - i * 0.05f)); // Decreasing alpha for outer glow rings
                }
            }

            // Draw cell borders - this creates the grid-like appearance
            DrawRectangleLines(x * CELL_SIZE, y * CELL_SIZE, CELL_SIZE, CELL_SIZE, borderColor);
        }
    }
    
    // Add a helpful message when the secret path is revealed
    // This appears only on hard difficulty after 7 deaths to guide the player
    if (diffculty == 3 && playerdeaths >= 7) {
        // Draw a semi-transparent background for the text to improve readability
        DrawRectangle(SCREEN_WIDTH/2 - 230, 5, 460, 30, (Color){0, 0, 0, 180});
        // Display guidance message in gold color to match the revealed path
        DrawText("Secret path revealed! Follow the golden path!", SCREEN_WIDTH/2 - 225, 10, 20, GOLD);
    }
}

void DrawPlayer()
{
    DrawCircle((playerPos.x * CELL_SIZE) + CELL_SIZE / 2, (playerPos.y * CELL_SIZE) + CELL_SIZE / 2, CELL_SIZE / 4, WHITE);
}

void DrawGameOverScreen()
{
    if (isnpc)
    {
        Rectangle messageBox = {
            SCREEN_WIDTH / 2 - 300,
            SCREEN_HEIGHT / 2 - 50,
            600,
            100};
        DrawRectangleRec(messageBox, ColorAlpha(BLACK, 0.7f));

        const char *message;
        switch (playerdeaths)
        {
        case 1:
            message = "U Died - Press T to Restart";
            break;
        case 2:
            message = "dont worry you got this - Press T to Restart";
            break;
        case 3:
            message = "next time ;) - Press T to Restart";
            break;
        case 4:
            message = "it EASY, come on - Press T to Restart";
            break;
        case 5:
            message = " its not this hard :/ - Press T to Restart";
            break;

        case 6:
            message = " I'm not sure what to say - Press T to Restart";
            break;

        case 7:
            message = " please go back to the lobby - Press o to save yourself";
            break;

        default:
            if (playerdeaths >= 8)
            {
                message = " I'm not programming more responses good luck";
            }
            break;
        }
        DrawText(message, messageBox.x + 10, messageBox.y + 30, 30, WHITE);
    }

    if (isnpc2 && diffculty == 2)
    {
        Rectangle messageBox = {
            SCREEN_WIDTH / 2 - 300,
            SCREEN_HEIGHT / 2 - 50,
            600,
            100};
        DrawRectangleRec(messageBox, ColorAlpha(BLACK, 0.7f));

        const char *message;
        switch (playerdeaths)
        {
        case 1:
            message = "You Died - Press T to Restart";
            break;
        case 2:
            message = "I believe in you - Press T to Restart";
            break;
        case 3:
            message = "Don't step there next time ;) - Press T to Restart";
            break;
        case 4:
            message = "I'll show you the map next time - Press T to Restart";
            break;
        case 5:
            message = "Hahaha you thought I would! ;) - Press T to Restart";
            break;
        case 6:
            message = "That's not the right path - Press T to Restart";
            break;
        case 7:
            message = "This is getting painful to watch - Press T to Restart";
            break;
        case 8:
            message = "Sending hopes and dreams your way - Press T to Restart";
            break;

        default:
            if (playerdeaths >= 9)
            {
                message = "im not programming more responses good luck";
            }
            break;
        }
        DrawText(message, messageBox.x + 10, messageBox.y + 30, 30, WHITE);
    }

    if (isnpc3 && diffculty == 3)
    {
        Rectangle messageBox = {
            SCREEN_WIDTH / 2 - 300,
            SCREEN_HEIGHT / 2 - 50,
            600,
            100};
        DrawRectangleRec(messageBox, ColorAlpha(BLACK, 0.7f));

        const char *message;
        switch (playerdeaths)
        {
        case 1:
            message = "U Died - Press T to Restart";
            break;
        case 2:
            message = "hahahaha ur not beating this one - Press T to Restart";
            break;
        case 3:
            message = " I forgot to tell you don't step there - Press T to Restart";
            break;
        case 4:
            message = " well its not there - Press T to Restart";
            break;
        case 5:
            message = "hahaahah that was a good one - Press T to Restart";
            break;
        case 6:
            message = " try again? - Press T to Restart";
            break;
        case 7:
            message = " please go back to the lobby - Press o to save yourself";
            break;
        default:
            if (playerdeaths >= 8)
            {
                message = "im not programming more responses good luck";
            }
            break;
        }
        DrawText(message, messageBox.x + 10, messageBox.y + 30, 30, WHITE);
    }
}

void DrawPausedScreen()
{
    // Draw a semi-transparent overlay for the fuzzy effect
    DrawRectangle(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT, (Color){0, 0, 0, 120});
    
    // Draw multiple offset semi-transparent copies of the screen texture to create blur
    for (int i = -3; i <= 3; i += 2) {
        for (int j = -3; j <= 3; j += 2) {
            if (i != 0 || j != 0) { // Skip the center position
                // Draw the screen texture with an offset and reduced alpha
                // This creates a fuzzy/blurry effect
                DrawTexturePro(
                    pauseScreenTexture.texture,
                    (Rectangle){0, 0, (float)pauseScreenTexture.texture.width, -(float)pauseScreenTexture.texture.height},
                    (Rectangle){i, j, SCREEN_WIDTH, SCREEN_HEIGHT},
                    (Vector2){0, 0},
                    0.0f,
                    (Color){255, 255, 255, 40}
                );
            }
        }
    }
    
    // Draw a dark overlay in the center for the pause message
    DrawRectangle(SCREEN_WIDTH/2 - 200, SCREEN_HEIGHT/2 - 60, 400, 120, (Color){0, 0, 0, 200});
    DrawRectangleLinesEx((Rectangle){SCREEN_WIDTH/2 - 200, SCREEN_HEIGHT/2 - 60, 400, 120}, 2, WHITE);
    
    // Draw pause message and instructions
    DrawText("PAUSED", SCREEN_WIDTH/2 - MeasureText("PAUSED", 40)/2, SCREEN_HEIGHT/2 - 40, 40, WHITE);
    DrawText("Press P to resume", SCREEN_WIDTH/2 - MeasureText("Press P to resume", 20)/2, SCREEN_HEIGHT/2 + 20, 20, LIGHTGRAY);
}

int main(void)
{
    // Initialize window and audio device
    InitWindow(SCREEN_WIDTH, SCREEN_HEIGHT, "Grid with Controllable Circle");
    InitAudioDevice();  // Initialize audio device
    
    // Create the pause screen texture
    pauseScreenTexture = LoadRenderTexture(SCREEN_WIDTH, SCREEN_HEIGHT);
    pauseTextureReady = true;
    
    //load background music
    backgroundMusic = LoadMusicStream("resources/music.mp3");
    
    // Check if music loaded successfully before playing
    bool musicLoaded = IsMusicReady(backgroundMusic);
    if (musicLoaded) {
        PlayMusicStream(backgroundMusic);
        SetMusicVolume(backgroundMusic, 0.5f);  // Set volume to 50%
    } else { // debug for the sound as it was not working when i added it
        printf("Failed to load background music. Game will continue without music.\n");
    }
    
    SetTargetFPS(60);
    InitPatternGrid(pattern_E);

    while (!WindowShouldClose())
    {
        // Update music stream only if loaded successfully
        if (musicLoaded) {
            UpdateMusicStream(backgroundMusic);
        }
        
        // Capture the current game screen if pause was just pressed
        if (IsKeyPressed(KEY_P) && !isPaused) {
            // Capture the current screen to the texture
            BeginTextureMode(pauseScreenTexture);
            ClearBackground(BLACK);
            
            if (diffculty != 0 && !isWin) {
                GameGrid();
                DrawPlayer();
            }
            
            EndTextureMode();
        }
        
        UpdatePlayer();

        BeginDrawing();
        ClearBackground(BLACK);

        if (diffculty == 0)
        {
            DrawStartScreen();
        }
        else if (isWin)
        {
            DrawWinScreen();
        }
        else
        {
            GameGrid();
            DrawPlayer();
            
            if (isPaused && pauseTextureReady) {
                DrawPausedScreen(); // Draw the fuzzy paused screen overlay
            }
        }

        // Only show the start text if we're not paused
        if (isStart && diffculty != 0 && !isPaused)
        {
            DrawText("START GAME", SCREEN_WIDTH / 2 - MeasureText("START", 40) / 2, SCREEN_HEIGHT / 2 - 20, 40, WHITE);
        }

        // Only show the game over screen if we're not paused
        if (!isPaused) {
            DrawGameOverScreen(); // Display the game over screen when the player dies
        }

        EndDrawing(); // End the current frame drawing
    }

    // Unload the pause texture
    if (pauseTextureReady) {
        UnloadRenderTexture(pauseScreenTexture); // Free the memory used by the pause screen texture
    }
    
    // Unload resources only if loaded successfully
    if (musicLoaded) {
        UnloadMusicStream(backgroundMusic); // Free the memory used by the background music
    }
    CloseAudioDevice(); // Close the audio device to release resources

    CloseWindow(); // Close the game window and terminate the application
    return 0; // Exit the program
}